/*
 * Copyright (c) 2020 Spigradle contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kr.entree.spigradle.module.spigot

import kr.entree.spigradle.data.SpigotDebug
import kr.entree.spigradle.internal.applyToConfigure
import kr.entree.spigradle.internal.lazyString
import kr.entree.spigradle.module.common.DebugTask.registerPreparePlugins
import kr.entree.spigradle.module.common.DebugTask.registerRunServer
import kr.entree.spigradle.module.common.Download
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.logging.LogLevel
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.Delete
import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.TaskProvider
import org.gradle.kotlin.dsl.register
import java.io.File

/**
 * Created by JunHyung Lim on 2020-06-03
 */
object SpigotDebugTask {
    const val TASK_GROUP_DEBUG = "${SpigotPlugin.TASK_GROUP} debug"
    const val BUILD_TOOLS_URL = "https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar"

    fun Project.registerDownloadBuildTool(debugOption: SpigotDebug): TaskProvider<Download> {
        return tasks.register("downloadSpigotBuildTools", Download::class) {
            group = TASK_GROUP_DEBUG
            description = "Download the BuildTools."
            source.set(BUILD_TOOLS_URL)
            destination.set(provider { debugOption.buildToolJar })
        }
    }

    fun Project.registerCleanSpigotBuild(debugOption: SpigotDebug): TaskProvider<Delete> {
        return tasks.register("cleanSpigotBuild", Delete::class) {
            group = TASK_GROUP_DEBUG
            description = "Delete all BuildTools directories."
            delete(debugOption.buildToolDirectory)
            delete(debugOption.buildToolOutputDirectory)
        }
    }

    fun Project.registerBuildSpigot(options: SpigotDebug): TaskProvider<JavaExec> {
        return tasks.register("buildSpigot", JavaExec::class) {
            group = TASK_GROUP_DEBUG
            description = "Build the Spigot using the BuildTools."
            outputs.cacheIf { true }
            outputs.dir(provider { File(options.buildToolDirectory, "CraftBukkit/target/classes") })
            logging.captureStandardOutput(LogLevel.DEBUG)
            classpath = files(provider { options.buildToolJar })
            setWorkingDir(provider { options.buildToolDirectory })
            args(
                    "--rev", lazyString { options.buildVersion },
                    "--output-dir", lazyString { options.buildToolOutputDirectory.absolutePath }
            )
            doFirst {
                // Remove empty directory created by gradle for avoid buildtools failure
                val classesDir = File(options.buildToolDirectory, "CraftBukkit/target/classes")
                val craftbukkitDir = File(options.buildToolDirectory, "CraftBukkit")
                if (classesDir.listFiles()?.isNotEmpty() != true) {
                    craftbukkitDir.deleteRecursively()
                }
            }
        }
    }

    fun Project.registerPrepareSpigot(options: SpigotDebug): TaskProvider<Copy> {
        return tasks.register("prepareSpigot", Copy::class) {
            group = TASK_GROUP_DEBUG
            description = "Copy the Spigot generated by BuildTools into the given path."
            from(provider { File(options.buildToolDirectory, "Spigot/Spigot-Server/target") }) {
                include("spigot*.jar")
            }
            into(provider { options.serverDirectory })
            rename { options.serverJar.name }
        }
    }

    fun Project.registerRunSpigot(debug: SpigotDebug): TaskProvider<JavaExec> {
        val serverJar = debug.serverJar
        return registerRunServer("Spigot", debug).applyToConfigure {
            group = TASK_GROUP_DEBUG
            description = "Startup the Spigot server."
            classpath = files(provider { serverJar })
            setWorkingDir(provider { debug.serverDirectory })
            doFirst {
                ensureMinecraftEULA(workingDir, debug.eula)
            }
        }
    }

    fun Project.registerPrepareSpigotPlugin(spigot: SpigotExtension): TaskProvider<Copy> {
        return registerPreparePlugins(
                "prepareSpigotPlugins",
                "name",
                "plugin.yml"
        ) { spigot.depends + spigot.softDepends }.applyToConfigure {
            group = TASK_GROUP_DEBUG
            into(provider { File(spigot.debug.serverDirectory, "plugins") })
        }
    }

    fun Project.registerDebugRun(name: String): TaskProvider<Task> {
        return tasks.register("debug$name") {
            group = TASK_GROUP_DEBUG
            description = "Startup the $name server with your plugin.jar."
        }
    }

    fun Project.registerDownloadPaper(debug: SpigotDebug): TaskProvider<Download> {
        return tasks.register("downloadPaper", Download::class) {
            group = TASK_GROUP_DEBUG
            description = "Download the Paperclip."
            source.set(provider { "https://papermc.io/api/v1/paper/${debug.buildVersion}/latest/download" })
            destination.set(provider { debug.serverJar })
        }
    }
}