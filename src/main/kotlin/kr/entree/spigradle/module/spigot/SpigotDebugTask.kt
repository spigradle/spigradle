package kr.entree.spigradle.module.spigot

import com.fasterxml.jackson.module.kotlin.readValue
import kr.entree.spigradle.internal.findArtifactJar
import kr.entree.spigradle.internal.notNull
import kr.entree.spigradle.module.common.Download
import kr.entree.spigradle.module.common.SpigradlePlugin
import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.Delete
import org.gradle.api.tasks.JavaExec
import org.gradle.kotlin.dsl.create
import org.gradle.kotlin.dsl.get
import org.gradle.kotlin.dsl.support.useToRun
import org.gradle.kotlin.dsl.withConvention
import java.io.File
import java.util.jar.JarFile

/**
 * Created by JunHyung Lim on 2020-06-03
 */
fun File.readBukkitPluginDescription() = runCatching {
    JarFile(this).run {
        getEntry("plugin.yml")?.run {
            getInputStream(this)
        }
    }?.useToRun {
        SpigradlePlugin.yaml.readValue<Map<String, Any>>(this)
    }
}.getOrNull() ?: emptyMap()

object SpigotDebugTask {
    fun Project.createDownloadBuildTool(debugOption: SpigotDebug): Download {
        return tasks.create("downloadSpigotBuildTools", Download::class).apply {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Download the BuildTools."
            source = SpigotPlugin.BUILD_TOOLS_URL
            afterEvaluate {
                destination = debugOption.buildToolJar
            }
        }
    }

    fun Project.createCleanSpigotBuild(debugOption: SpigotDebug): Delete {
        return tasks.create("cleanSpigotBuild", Delete::class).apply {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Delete all BuildTools directories"
            delete(debugOption.buildToolDirectory)
            delete(debugOption.buildToolOutputDirectory)
        }
    }

    fun Project.createBuildSpigot(options: SpigotDebug): JavaExec {
        return tasks.create("buildSpigot", JavaExec::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Build the spigot.jar using the BuildTools."
            outputs.cacheIf { true }
            afterEvaluate {
                outputs.dir(File(options.buildToolJar.parentFile, "CraftBukkit/target/classes"))
                classpath = files(options.buildToolJar)
                workingDir = options.buildToolDirectory
                args(
                        "--rev", options.buildVersion,
                        "--output-dir", options.buildToolOutputDirectory
                )
            }
        }
    }

    fun Project.createPrepareSpigot(options: SpigotDebug): Task {
        return tasks.create("prepareSpigot", Copy::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Copy the spigot.jar generated by BuildTools into the given path."
            afterEvaluate {
                from(File(options.buildToolDirectory, "Spigot/Spigot-Server/target")) {
                    include("spigot*.jar")
                }
                into(options.serverDirectory)
                rename { options.serverJar.name }
            }
        }
    }

    fun Project.createRunSpigot(debug: SpigotDebug): JavaExec {
        val serverJar = debug.serverJar
        return tasks.create("runSpigot", JavaExec::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Startup the spigot server."
            standardInput = System.`in`
            args("nogui")
            afterEvaluate {
                classpath = files(serverJar)
                workingDir = serverJar.parentFile
                jvmArgs("-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=${debug.agentPort}")
            }
            doFirst {
                if (!debug.eula) {
                    throw GradleException("""
                        Please set the 'eula' property to true if you agree the Mojang EULA.
                        https://account.mojang.com/documents/minecraft_eula
                    """.trimIndent())
                }
                File(workingDir, "eula.txt").writeText("eula=true")
            }
        }
    }

    fun Project.createPreparePlugin(spigot: SpigotExtension): Task {
        return tasks.create("preparePlugin") {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Copy the plugin jars into the server."
            doLast {
                val serverPluginsDir = File(spigot.debug.serverDirectory, "plugins")
                val pluginJar = notNull(tasks.findArtifactJar()) { "Couldn't find a plugin.jar" }
                val needPlugins = (spigot.depends + spigot.softDepends).toMutableSet()
                // Remove already had plugins
                (serverPluginsDir.listFiles() ?: emptyArray()).asSequence().takeWhile {
                    needPlugins.isNotEmpty()
                }.mapNotNull {
                    it.readBukkitPluginDescription()["name"]?.toString()
                }.forEach {
                    needPlugins -= it
                }
                copy {
                    from(pluginJar)
                    into(serverPluginsDir)
                    // Find depend plugins from classpath and copy into server
                    project.withConvention(JavaPluginConvention::class) {
                        sourceSets["main"].compileClasspath
                    }.asSequence().takeWhile {
                        needPlugins.isNotEmpty()
                    }.mapNotNull { file ->
                        file.readBukkitPluginDescription()["name"]?.let { pluginName ->
                            file to pluginName.toString()
                        }
                    }.filter { (_, pluginName) ->
                        needPlugins.remove(pluginName)
                    }.forEach { (file, _) ->
                        logger.info("Plugin copied from ${file.absolutePath}")
                        from(file)
                    }
                }
            }
        }
    }

    fun Project.createDebugRun(name: String): Task {
        return tasks.create("debug$name") {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Startup the $name server with your plugin.jar"
        }
    }

    fun Project.createDownloadPaper(debug: SpigotDebug): Task {
        return tasks.create("downloadPaper", Download::class).apply {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Download the Paperclip."
            afterEvaluate {
                source = source ?: "https://papermc.io/api/v1/paper/${debug.buildVersion}/latest/download"
                destination = debug.serverJar
            }
        }
    }
}