package kr.entree.spigradle.module.spigot

import kr.entree.spigradle.internal.cachingProvider
import kr.entree.spigradle.internal.findArtifactJar
import kr.entree.spigradle.internal.lazyString
import kr.entree.spigradle.module.common.Download
import org.gradle.api.GradleException
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.logging.LogLevel
import org.gradle.api.plugins.JavaPluginConvention
import org.gradle.api.tasks.Copy
import org.gradle.api.tasks.Delete
import org.gradle.api.tasks.JavaExec
import org.gradle.api.tasks.TaskProvider
import org.gradle.kotlin.dsl.get
import org.gradle.kotlin.dsl.register
import org.gradle.kotlin.dsl.withConvention
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

/**
 * Created by JunHyung Lim on 2020-06-03
 */
object SpigotDebugTask { // TODO: Normalize for bungeecord, nukkitX
    fun Project.createDownloadBuildTool(debugOption: SpigotDebug): TaskProvider<Download> {
        return tasks.register("downloadSpigotBuildTools", Download::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Download the BuildTools."
            source.set(SpigotPlugin.BUILD_TOOLS_URL)
            destination.set(provider { debugOption.buildToolJar })
        }
    }

    fun Project.createCleanSpigotBuild(debugOption: SpigotDebug): TaskProvider<Delete> {
        return tasks.register("cleanSpigotBuild", Delete::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Delete all BuildTools directories"
            delete(debugOption.buildToolDirectory)
            delete(debugOption.buildToolOutputDirectory)
        }
    }

    fun Project.createBuildSpigot(options: SpigotDebug): TaskProvider<JavaExec> {
        return tasks.register("buildSpigot", JavaExec::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Build the spigot.jar using the BuildTools."
            outputs.cacheIf { true }
            outputs.dir(provider { File(options.buildToolDirectory, "CraftBukkit/target/classes") })
            logging.captureStandardOutput(LogLevel.DEBUG)
            classpath = files(provider { options.buildToolJar })
            setWorkingDir(provider { options.buildToolDirectory })
            args(
                    "--rev", lazyString { options.buildVersion },
                    "--output-dir", lazyString { options.buildToolOutputDirectory.absolutePath }
            )
            doFirst {
                // Remove empty directory created by gradle for avoid buildtools failure
                val classesDir = File(options.buildToolDirectory, "CraftBukkit/target/classes")
                val craftbukkitDir = File(options.buildToolDirectory, "CraftBukkit")
                if (classesDir.listFiles()?.isNotEmpty() != true) {
                    craftbukkitDir.deleteRecursively()
                }
            }
        }
    }

    fun Project.createPrepareSpigot(options: SpigotDebug): TaskProvider<Copy> {
        return tasks.register("prepareSpigot", Copy::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Copy the spigot.jar generated by BuildTools into the given path."
            from(provider { File(options.buildToolDirectory, "Spigot/Spigot-Server/target") }) {
                include("spigot*.jar")
            }
            into(provider { options.serverDirectory })
            rename { options.serverJar.name }
        }
    }

    fun Project.createRunSpigot(debug: SpigotDebug): TaskProvider<JavaExec> {
        val serverJar = debug.serverJar
        return tasks.register("runSpigot", JavaExec::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Startup the spigot server."
            standardInput = System.`in`
            classpath = files(provider { serverJar })
            logging.captureStandardOutput(LogLevel.LIFECYCLE)
            setWorkingDir(provider { serverJar.parentFile })
            jvmArgs(lazyString { "-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=${debug.agentPort}" })
            args("nogui")
            doFirst {
                File(workingDir, "eula.txt").takeIf { eulaFile ->
                    !eulaFile.isFile && (debug.eula || logger.run {
                        log(LogLevel.QUIET, """
                            Are you agree the Mojang EULA? (https://account.mojang.com/documents/minecraft_eula)
                            Your input (y)es or (n)o:
                        """.trimIndent())
                        readLine()?.equals("y", ignoreCase = true) == true
                    })
                }?.apply {
                    writeText("""
                        # Accepted by Spigradle
                        # ${DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(LocalDateTime.now())}
                        eula=true
                    """.trimIndent())
                } ?: throw GradleException("""
                    Please set the 'eula' property in spigot {} block to true if you agree the Mojang EULA.
                    https://account.mojang.com/documents/minecraft_eula
                """.trimIndent())
            }
        }
    }

    fun Project.createPreparePlugin(spigot: SpigotExtension): TaskProvider<Copy> {
        return tasks.register("prepareSpigotPlugins", Copy::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Copy the plugin jars into the server."
            into(provider { File(spigot.debug.serverDirectory, "plugins") })
            from(cachingProvider { tasks.findArtifactJar() ?: files() })
            from(cachingProvider {
                val needPlugins = (spigot.depends + spigot.softDepends).toMutableSet()
                // Remove already had plugins
                destinationDir.readAllBukkitPluginDescription()
                        .takeWhile { needPlugins.isNotEmpty() }
                        .mapNotNull { it["name"]?.toString() }
                        .forEach { needPlugins -= it }
                // Find depend plugins from classpath
                project.withConvention(JavaPluginConvention::class) {
                    sourceSets["main"]
                }.findBukkitPluginFromClasspath()
                        .takeWhile { needPlugins.isNotEmpty() }
                        .filter { (_, desc) ->
                            val pluginName = desc["name"]?.toString()
                            pluginName != null && needPlugins.remove(pluginName)
                        }.mapNotNull { it.first }.toList()
            })
        }
    }

    fun Project.createDebugRun(name: String): TaskProvider<Task> {
        return tasks.register("debug$name") {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Startup the $name server with your plugin.jar"
        }
    }

    fun Project.createDownloadPaper(debug: SpigotDebug): TaskProvider<Download> {
        return tasks.register("downloadPaper", Download::class) {
            group = SpigotPlugin.TASK_GROUP_DEBUG
            description = "Download the Paperclip."
            source.set(provider { "https://papermc.io/api/v1/paper/${debug.buildVersion}/latest/download" })
            destination.set(provider { debug.serverJar })
        }
    }
}